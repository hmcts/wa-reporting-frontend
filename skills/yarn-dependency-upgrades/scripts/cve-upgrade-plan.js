#!/usr/bin/env node

const { readFileSync } = require('node:fs');
const { resolve } = require('node:path');
const { spawnSync } = require('node:child_process');

const auditFile = process.argv[2] || 'yarn-audit-known-issues';
const pkgPath = resolve(process.cwd(), 'package.json');

const MARKERS = ['@npm:', '@workspace:', '@patch:', '@portal:', '@file:', '@link:', '@git:', '@http:', '@https:'];

function parseNameFromDescriptor(value) {
  if (typeof value !== 'string' || value.length === 0) {
    return null;
  }

  for (const marker of MARKERS) {
    const markerIndex = value.indexOf(marker);
    if (markerIndex > 0) {
      return value.slice(0, markerIndex);
    }
  }

  const match = value.match(/^(@[^/]+\/[^@]+|[^@]+)@/);
  if (match) {
    return match[1];
  }

  return value;
}

function runYarn(args) {
  const result = spawnSync('yarn', args, {
    cwd: process.cwd(),
    encoding: 'utf8',
    maxBuffer: 10 * 1024 * 1024,
  });

  if (result.status !== 0) {
    const stderr = (result.stderr || '').trim();
    const stdout = (result.stdout || '').trim();
    const details = stderr || stdout || `exit code ${result.status}`;
    throw new Error(`yarn ${args.join(' ')} failed: ${details}`);
  }

  return result.stdout || '';
}

function parseNdjsonFile(path) {
  const absolutePath = resolve(process.cwd(), path);
  const raw = readFileSync(absolutePath, 'utf8');
  const lines = raw
    .split(/\r?\n/)
    .map(line => line.trim())
    .filter(Boolean);

  return lines.map((line, idx) => {
    try {
      return JSON.parse(line);
    } catch (error) {
      throw new Error(`Invalid JSON in ${path} on line ${idx + 1}: ${error.message}`);
    }
  });
}

function parseWhy(packageName) {
  const output = runYarn(['why', packageName, '--json']);
  const lines = output
    .split(/\r?\n/)
    .map(line => line.trim())
    .filter(Boolean);

  const parents = new Set();
  const descriptors = new Set();

  for (const line of lines) {
    let row;
    try {
      row = JSON.parse(line);
    } catch {
      continue;
    }

    if (typeof row?.value === 'string' && !row.value.includes('@workspace:')) {
      const parentName = parseNameFromDescriptor(row.value);
      if (parentName) {
        parents.add(parentName);
      }
    }

    if (row?.children && typeof row.children === 'object') {
      for (const child of Object.values(row.children)) {
        if (!child || typeof child !== 'object') {
          continue;
        }
        if (typeof child.descriptor === 'string') {
          const childName = parseNameFromDescriptor(child.descriptor);
          if (childName === packageName) {
            descriptors.add(child.descriptor);
          }
        }
      }
    }
  }

  return {
    parents: [...parents],
    descriptors: [...descriptors],
  };
}

function parseDependents(issue) {
  const rawDependents = issue?.children?.Dependents;
  if (!Array.isArray(rawDependents)) {
    return [];
  }

  const names = new Set();

  for (const item of rawDependents) {
    const dependentName = parseNameFromDescriptor(item);
    if (dependentName) {
      names.add(dependentName);
    }
  }

  return [...names];
}

function findUpgradeTarget(vulnerablePackage, directDependencies) {
  if (directDependencies.has(vulnerablePackage)) {
    return {
      action: 'upgrade-direct-dependency',
      upgradeTarget: vulnerablePackage,
      chain: [vulnerablePackage],
    };
  }

  const visited = new Set([vulnerablePackage]);
  const queue = [{ name: vulnerablePackage, chain: [vulnerablePackage] }];

  while (queue.length > 0) {
    const current = queue.shift();
    const whyInfo = parseWhy(current.name);

    for (const parent of whyInfo.parents) {
      if (visited.has(parent)) {
        continue;
      }

      const nextChain = [...current.chain, parent];
      if (directDependencies.has(parent)) {
        return {
          action: 'upgrade-parent-dependency',
          upgradeTarget: parent,
          chain: nextChain,
        };
      }

      visited.add(parent);
      queue.push({ name: parent, chain: nextChain });
    }
  }

  return {
    action: 'set-resolution',
    upgradeTarget: null,
    chain: [vulnerablePackage],
  };
}

function getLatestVersion(packageName) {
  const output = runYarn(['npm', 'info', packageName, '--fields', 'version', '--json'])
    .split(/\r?\n/)
    .map(line => line.trim())
    .filter(Boolean);

  for (const line of output) {
    try {
      const row = JSON.parse(line);
      if (row?.name === packageName && typeof row?.version === 'string') {
        return row.version;
      }
    } catch {
      // Ignore invalid JSON lines.
    }
  }

  return null;
}

function main() {
  let pkg;
  try {
    pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));
  } catch (error) {
    console.error(`Cannot read package.json at ${pkgPath}: ${error.message}`);
    process.exit(1);
  }

  const directDependencies = new Set(Object.keys(pkg.dependencies || {}));

  let issues;
  try {
    issues = parseNdjsonFile(auditFile);
  } catch (error) {
    console.error(error.message);
    process.exit(1);
  }

  if (issues.length === 0) {
    console.log(JSON.stringify({ auditFile, issues: [], message: 'No CVEs found.' }, null, 2));
    return;
  }

  const seenPackages = new Set();
  const plans = [];

  for (const issue of issues) {
    const vulnerablePackage = issue?.value;
    if (typeof vulnerablePackage !== 'string' || vulnerablePackage.length === 0) {
      continue;
    }

    if (seenPackages.has(vulnerablePackage)) {
      continue;
    }
    seenPackages.add(vulnerablePackage);

    const strategy = findUpgradeTarget(vulnerablePackage, directDependencies);
    const whyForVulnerable = parseWhy(vulnerablePackage);

    const basePlan = {
      package: vulnerablePackage,
      issueId: issue?.children?.ID ?? null,
      severity: issue?.children?.Severity ?? null,
      advisoryUrl: issue?.children?.URL ?? null,
      vulnerableVersions: issue?.children?.['Vulnerable Versions'] ?? null,
      treeVersions: issue?.children?.['Tree Versions'] ?? null,
      dependents: parseDependents(issue),
      action: strategy.action,
      dependencyChain: strategy.chain,
      upgradeTarget: strategy.upgradeTarget,
      vulnerableDescriptors: whyForVulnerable.descriptors,
      commands: [],
      notes: [],
    };

    if (strategy.action === 'upgrade-direct-dependency' || strategy.action === 'upgrade-parent-dependency') {
      basePlan.commands.push(`yarn up ${strategy.upgradeTarget}@latest`);
      basePlan.notes.push('Re-run audit after upgrade; only use resolutions if CVE remains.');
    } else {
      const latestVersion = getLatestVersion(vulnerablePackage);
      if (!latestVersion) {
        basePlan.notes.push('Cannot determine latest version. Run `yarn npm info <pkg> --fields version --json`.');
      } else {
        for (const descriptor of whyForVulnerable.descriptors) {
          basePlan.commands.push(`yarn set resolution ${descriptor} npm:${latestVersion}`);
        }
        if (basePlan.commands.length === 0) {
          basePlan.notes.push('No descriptors found from `yarn why`; inspect manually before `yarn set resolution`.');
        }
      }
      basePlan.notes.push('After `yarn set resolution`, persist in package.json resolutions if needed.');
    }

    plans.push(basePlan);
  }

  console.log(
    JSON.stringify(
      {
        auditFile,
        issues: plans,
      },
      null,
      2
    )
  );
}

main();
